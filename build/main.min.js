"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("./js/init");

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calcValues = void 0;
const sceneInfo_1 = require("./sceneInfo");
function calcValues(values, currentYOffet, currentScene) {
    // 현재 씬(스크롤섹션)에서 스크롤된 범위를 비율로 구하기
    if (!values)
        return 0;
    let rv;
    const scrollHeight = sceneInfo_1.sceneInfo[currentScene].scrollHeight;
    const scrollRatio = currentYOffet / scrollHeight;
    let partScrollStart = 0;
    let partScrollEnd = 0;
    let partScrollHeight = 0;
    if (values.start !== undefined && values.end !== undefined) {
        partScrollStart = values.start * scrollHeight;
        partScrollEnd = values.end * scrollHeight;
        partScrollHeight = partScrollEnd - partScrollStart;
        if (currentYOffet < partScrollStart) {
            rv = values.in;
        }
        else if (currentYOffet > partScrollEnd) {
            rv = values.out;
        }
        else {
            rv = ((currentYOffet - partScrollStart) / partScrollHeight) * (values.out - values.in) + values.in;
        }
    }
    else {
        rv = (values.out - values.in) * scrollRatio + values.in;
    }
    return rv;
}
exports.calcValues = calcValues;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.smoothingVideo = void 0;
const sceneInfo_1 = require("./sceneInfo");
const main_1 = require("./main");
const setLayout_1 = require("./setLayout");
const setCanvasImages_1 = require("./setCanvasImages");
const calcValue_1 = require("./calcValue");
// let yOffset = 0; // window.pageYOffset 대신 쓸 변수
let prevScrollHeight = 0; // 현재 스크롤 위치(yOffset)보다 이전에 위치한 스크롤 섹션들의 스크롤 높이값의 합
let currentScene = 0; // 현재 활성화된(눈 앞에 보고 있는) 씬(scroll-section)
function checkMenu(yOffset) {
    if (yOffset > 44) {
        document.body.classList.add("local-nav-sticky");
    }
    else {
        document.body.classList.remove("local-nav-sticky");
    }
}
function scrollLoop(yOffset) {
    prevScrollHeight = 0;
    let entering = false; // debounce
    for (let i = 0; i < currentScene; i++) {
        prevScrollHeight += sceneInfo_1.sceneInfo[i].scrollHeight;
    }
    if (yOffset < prevScrollHeight + sceneInfo_1.sceneInfo[currentScene].scrollHeight) {
        document.body.classList.remove("scroll-effect-end");
    }
    if (yOffset > prevScrollHeight + sceneInfo_1.sceneInfo[currentScene].scrollHeight) {
        entering = true;
        if (currentScene === sceneInfo_1.sceneInfo.length - 1) {
            document.body.classList.add("scroll-effect-end");
        }
        if (currentScene < sceneInfo_1.sceneInfo.length - 1) {
            currentScene++;
        }
        document.body.setAttribute("id", `show-scene-${currentScene}`);
    }
    if (yOffset < prevScrollHeight) {
        entering = true;
        if (currentScene === 0)
            return;
        currentScene--;
        document.body.setAttribute("id", `show-scene-${currentScene}`);
    }
    if (entering)
        return;
    main_1.playAnimation(yOffset, prevScrollHeight, currentScene);
}
function smoothingVideo(prevScrollHeight, imageSequence, videoImages, context) {
    let acc = 0.1;
    let delayedYOffset = 0;
    let rafId;
    let rafState;
    function loop() {
        delayedYOffset = delayedYOffset + (pageYOffset - delayedYOffset) * acc;
        const currentYOffset = delayedYOffset - prevScrollHeight;
        if (currentScene === 0 || currentScene === 2) {
            const sequence = Math.round(calcValue_1.calcValues(imageSequence, currentYOffset, currentScene));
            if (videoImages[sequence]) {
                context.drawImage(videoImages[sequence], 0, 0);
            }
        }
        rafId = requestAnimationFrame(loop);
        if (Math.abs(pageYOffset - delayedYOffset) < 1) {
            cancelAnimationFrame(rafId);
            rafState = false;
        }
    }
    window.addEventListener("scroll", () => {
        if (!rafState) {
            rafId = requestAnimationFrame(loop);
            rafState = true;
        }
    });
}
exports.smoothingVideo = smoothingVideo;
function afterLoaded() {
    window.addEventListener("resize", () => {
        if (window.innerWidth > 900) {
            window.location.reload();
            // setLayout(window.pageYOffset, currentScene);
            // sceneInfo[3].values.rectStartY = 0;
        }
    });
    window.addEventListener("orientationchange", () => {
        window.scrollTo(0, 0);
        setTimeout(() => {
            // setLayout(window.pageYOffset, currentScene);
            // sceneInfo[3].values.rectStartY = 0;
            window.location.reload();
        }, 500);
    });
    window.addEventListener("scroll", () => {
        scrollLoop(window.pageYOffset);
        checkMenu(window.pageYOffset);
    });
    document.querySelector(".loading").addEventListener("transitionend", (e) => {
        document.body.removeChild(e.currentTarget);
    });
}
window.addEventListener("load", () => {
    document.body.classList.remove("before-load");
    setLayout_1.setLayout(window.pageYOffset, currentScene);
    const objs = sceneInfo_1.sceneInfo[0].objs;
    objs.context.drawImage(objs.videoImages[0], 0, 0);
    let tempYOffset = pageYOffset;
    let tempScrollCount = 0;
    if (tempYOffset > 0) {
        let siId = setInterval(() => {
            window.scrollTo(0, tempYOffset);
            tempYOffset += 2;
            if (tempScrollCount++ > 10) {
                clearInterval(siId);
            }
        }, 20);
    }
    afterLoaded();
});
setCanvasImages_1.setCanvasImages();
setLayout_1.setLayout(window.pageYOffset, currentScene);

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.playAnimation = void 0;
const sceneInfo_1 = require("./sceneInfo");
const calcValue_1 = require("./calcValue");
const init_1 = require("./init");
let scene1 = true;
let scene2 = true;
function playAnimation(yOffset, prevScrollHeight, currentScene) {
    const objs = sceneInfo_1.sceneInfo[currentScene].objs;
    const values = sceneInfo_1.sceneInfo[currentScene].values;
    const currentYOffset = yOffset - prevScrollHeight;
    const scrollHeight = sceneInfo_1.sceneInfo[currentScene].scrollHeight;
    const scrollRatio = currentYOffset / scrollHeight;
    switch (currentScene) {
        case 0: {
            const { messageA_opacity_in, messageA_opacity_out, messageA_translateY_in, messageA_translateY_out, messageB_opacity_in, messageB_opacity_out, messageB_translateY_in, messageB_translateY_out, messageC_opacity_in, messageC_opacity_out, messageC_translateY_in, messageC_translateY_out, messageD_opacity_in, messageD_opacity_out, messageD_translateY_in, messageD_translateY_out, imageSequence, canvas_opacity, } = values;
            const { messageA, messageB, messageC, messageD, canvas, context, videoImages } = objs;
            const triggerA = ((messageA_opacity_in.end || 0) + (messageA_opacity_out.start || 0)) / 2;
            const triggerB = ((messageB_opacity_in.end || 0) + (messageB_opacity_out.start || 0)) / 2;
            const triggerC = ((messageC_opacity_in.end || 0) + (messageC_opacity_out.start || 0)) / 2;
            const triggerD = (((messageD_opacity_in === null || messageD_opacity_in === void 0 ? void 0 : messageD_opacity_in.end) || 0) + ((messageD_opacity_out === null || messageD_opacity_out === void 0 ? void 0 : messageD_opacity_out.start) || 0)) / 2;
            if (scene1) {
                init_1.smoothingVideo(prevScrollHeight, imageSequence, videoImages, context);
                scene1 = false;
            }
            // const sequence = Math.round(calcValues(imageSequence, currentYOffset, currentScene));
            // context.drawImage(videoImages[sequence], 0, 0);
            canvas.style.opacity = `${calcValue_1.calcValues(canvas_opacity, currentYOffset, currentScene)}`;
            if (scrollRatio <= triggerA) {
                // in
                messageA.style.opacity = `${calcValue_1.calcValues(messageA_opacity_in, currentYOffset, currentScene)}`;
                messageA.style.transform = `translate3d(0, ${calcValue_1.calcValues(messageA_translateY_in, currentYOffset, currentScene)}%, 0)`;
            }
            else {
                // out
                messageA.style.opacity = `${calcValue_1.calcValues(messageA_opacity_out, currentYOffset, currentScene)}`;
                messageA.style.transform = `translate3d(0, ${calcValue_1.calcValues(messageA_translateY_out, currentYOffset, currentScene)}%, 0)`;
            }
            if (scrollRatio <= triggerB) {
                // in
                messageB.style.opacity = `${calcValue_1.calcValues(messageB_opacity_in, currentYOffset, currentScene)}`;
                messageB.style.transform = `translate3d(0, ${calcValue_1.calcValues(messageB_translateY_in, currentYOffset, currentScene)}%, 0)`;
            }
            else {
                // out
                messageB.style.opacity = `${calcValue_1.calcValues(messageB_opacity_out, currentYOffset, currentScene)}`;
                messageB.style.transform = `translate3d(0, ${calcValue_1.calcValues(messageB_translateY_out, currentYOffset, currentScene)}%, 0)`;
            }
            if (scrollRatio <= triggerC) {
                // in
                messageC.style.opacity = `${calcValue_1.calcValues(messageC_opacity_in, currentYOffset, currentScene)}`;
                messageC.style.transform = `translate3d(0, ${calcValue_1.calcValues(messageC_translateY_in, currentYOffset, currentScene)}%, 0)`;
            }
            else {
                // out
                messageC.style.opacity = `${calcValue_1.calcValues(messageC_opacity_out, currentYOffset, currentScene)}`;
                messageC.style.transform = `translate3d(0, ${calcValue_1.calcValues(messageC_translateY_out, currentYOffset, currentScene)}%, 0)`;
            }
            if (scrollRatio <= triggerD) {
                // in
                messageD.style.opacity = `${calcValue_1.calcValues(messageD_opacity_in, currentYOffset, currentScene)}`;
                messageD.style.transform = `translate3d(0, ${calcValue_1.calcValues(messageD_translateY_in, currentYOffset, currentScene)}%, 0)`;
            }
            else {
                // out
                messageD.style.opacity = `${calcValue_1.calcValues(messageD_opacity_out, currentYOffset, currentScene)}`;
                messageD.style.transform = `translate3d(0, ${calcValue_1.calcValues(messageD_translateY_out, currentYOffset, currentScene)}%, 0)`;
            }
            break;
        }
        case 1: {
            break;
        }
        case 2: {
            const { messageA_opacity_in, messageA_opacity_out, messageA_translateY_in, messageA_translateY_out, messageB_opacity_in, messageB_opacity_out, messageB_translateY_in, messageB_translateY_out, messageC_opacity_in, messageC_opacity_out, messageC_translateY_in, messageC_translateY_out, pinB_opacity_in, pinB_opacity_out, pinB_scaleY, pinC_opacity_in, pinC_opacity_out, pinC_scaleY, imageSequence, canvas_opacity_in, canvas_opacity_out, } = values;
            const { messageA, messageB, messageC, pinB, pinC, context, canvas, videoImages } = objs;
            const triggerA = ((messageA_opacity_in.end || 0) + (messageA_opacity_out.start || 0)) / 2;
            const triggerB = ((messageB_opacity_in.end || 0) + (messageB_opacity_out.start || 0)) / 2;
            const triggerC = ((messageC_opacity_in.end || 0) + (messageC_opacity_out.start || 0)) / 2;
            if (scene2) {
                init_1.smoothingVideo(prevScrollHeight, imageSequence, videoImages, context);
                scene2 = false;
            }
            // const sequence = Math.round(calcValues(imageSequence, currentYOffset, currentScene));
            // context.drawImage(videoImages[sequence], 0, 0);
            if (scrollRatio <= 0.5) {
                canvas.style.opacity = `${calcValue_1.calcValues(canvas_opacity_in, currentYOffset, currentScene)}`;
            }
            else {
                canvas.style.opacity = `${calcValue_1.calcValues(canvas_opacity_out, currentYOffset, currentScene)}`;
            }
            if (scrollRatio <= triggerA) {
                // in
                messageA.style.opacity = `${calcValue_1.calcValues(messageA_opacity_in, currentYOffset, currentScene)}`;
                messageA.style.transform = `translate3d(0, ${calcValue_1.calcValues(messageA_translateY_in, currentYOffset, currentScene)}%, 0)`;
            }
            else {
                // out
                messageA.style.opacity = `${calcValue_1.calcValues(messageA_opacity_out, currentYOffset, currentScene)}`;
                messageA.style.transform = `translate3d(0, ${calcValue_1.calcValues(messageA_translateY_out, currentYOffset, currentScene)}%, 0)`;
            }
            if (scrollRatio <= triggerB) {
                // in
                messageB.style.opacity = `${calcValue_1.calcValues(messageB_opacity_in, currentYOffset, currentScene)}`;
                messageB.style.transform = `translate3d(0, ${calcValue_1.calcValues(messageB_translateY_in, currentYOffset, currentScene)}%, 0)`;
                pinB.style.transform = `scaleY(${calcValue_1.calcValues(pinB_scaleY, currentYOffset, currentScene)})`;
            }
            else {
                // out
                messageB.style.opacity = `${calcValue_1.calcValues(messageB_opacity_out, currentYOffset, currentScene)}`;
                messageB.style.transform = `translate3d(0, ${calcValue_1.calcValues(messageB_translateY_out, currentYOffset, currentScene)}%, 0)`;
            }
            if (scrollRatio <= triggerC) {
                // in
                messageC.style.opacity = `${calcValue_1.calcValues(messageC_opacity_in, currentYOffset, currentScene)}`;
                messageC.style.transform = `translate3d(0, ${calcValue_1.calcValues(messageC_translateY_in, currentYOffset, currentScene)}%, 0)`;
                pinC.style.transform = `scaleY(${calcValue_1.calcValues(pinC_scaleY, currentYOffset, currentScene)})`;
            }
            else {
                // out
                messageC.style.opacity = `${calcValue_1.calcValues(messageC_opacity_out, currentYOffset, currentScene)}`;
                messageC.style.transform = `translate3d(0, ${calcValue_1.calcValues(messageC_translateY_out, currentYOffset, currentScene)}%.0 )`;
            }
            // 3 section canvas 미리 그리기
            if (scrollRatio >= 0.9) {
                const objs = sceneInfo_1.sceneInfo[3].objs;
                const values = sceneInfo_1.sceneInfo[3].values;
                const { canvas, context, images } = objs;
                const { rect1X, rect2X } = values;
                const widthRatio = window.innerWidth / canvas.width;
                const heightRatio = window.innerHeight / canvas.height;
                const canvasScaleRatio = Math.max(widthRatio, heightRatio);
                canvas.style.transform = `scale(${canvasScaleRatio})`;
                context.fillStyle = "white";
                context.drawImage(images[0], 0, 0);
                // 캔버스 사이즈에 맞춰 가정한 innerWidth와 innerHeight
                const recalculatedInnerWidth = document.body.offsetWidth / canvasScaleRatio;
                const recalculatedInnerHeight = window.innerHeight / canvasScaleRatio;
                const whiteRectWidth = recalculatedInnerWidth * 0.15;
                rect1X.in = (canvas.width - recalculatedInnerWidth) / 2;
                rect1X.out = rect1X.in - whiteRectWidth;
                rect2X.in = rect1X.in + recalculatedInnerWidth - whiteRectWidth;
                rect2X.out = rect2X.in + whiteRectWidth;
                context.fillRect(rect1X.in, 0, Math.floor(whiteRectWidth), recalculatedInnerHeight);
                context.fillRect(rect2X.in, 0, Math.floor(whiteRectWidth), recalculatedInnerHeight);
            }
            break;
        }
        case 3: {
            // 가로/세로 모두 꽉 차게 하기 위해 여기서 계산 필요
            const { canvas, context, images, canvasCaption } = objs;
            const { rect1X, rect2X, rectStartY, imageBlendHeight, canvas_scale, canvasCaption_opacity, canvasCaption_translateY, } = values;
            const widthRatio = window.innerWidth / canvas.width;
            const heightRatio = window.innerHeight / canvas.height;
            const canvasScaleRatio = Math.max(widthRatio, heightRatio);
            canvas.style.transform = `scale(${canvasScaleRatio})`;
            context.fillStyle = "white";
            context.drawImage(images[0], 0, 0);
            // 캔버스 사이즈에 맞춰 가정한 innerWidth와 innerHeight
            const recalculatedInnerWidth = document.body.offsetWidth / canvasScaleRatio;
            const recalculatedInnerHeight = window.innerHeight / canvasScaleRatio;
            if (rectStartY === 0) {
                // (values as Section3Values).rectStartY = canvas.getBoundingClientRect().top;
                values.rectStartY =
                    canvas.offsetTop + (canvas.height - canvas.height * canvasScaleRatio) / 2;
                rect1X.start = window.innerHeight / 2 / scrollHeight;
                rect2X.start = window.innerHeight / 2 / scrollHeight;
                rect1X.end = values.rectStartY / scrollHeight;
                rect2X.end = values.rectStartY / scrollHeight;
            }
            const whiteRectWidth = recalculatedInnerWidth * 0.15;
            rect1X.in = (canvas.width - recalculatedInnerWidth) / 2;
            rect1X.out = rect1X.in - whiteRectWidth;
            rect2X.in = rect1X.in + recalculatedInnerWidth - whiteRectWidth;
            rect2X.out = rect2X.in + whiteRectWidth;
            // context.fillRect(rect1X.in, 0, Math.floor(whiteRectWidth), recalculatedInnerHeight);
            // context.fillRect(rect2X.in, 0, Math.floor(whiteRectWidth), recalculatedInnerHeight);
            context.fillRect(Math.floor(calcValue_1.calcValues(rect1X, currentYOffset, currentScene)), 0, Math.floor(whiteRectWidth), recalculatedInnerHeight);
            context.fillRect(calcValue_1.calcValues(rect2X, currentYOffset, currentScene), 0, Math.floor(whiteRectWidth), recalculatedInnerHeight);
            if (scrollRatio < rect1X.end) {
                canvas.classList.remove("sticky");
            }
            else {
                imageBlendHeight.out = canvas.height;
                imageBlendHeight.start = rect1X.end;
                imageBlendHeight.end = imageBlendHeight.start + 0.2;
                const blendHeight = calcValue_1.calcValues(imageBlendHeight, currentYOffset, currentScene);
                context.drawImage(images[1], 0, canvas.height - blendHeight, canvas.width, blendHeight, 0, canvas.height - blendHeight, canvas.width, blendHeight);
                canvas.classList.add("sticky");
                canvas.style.top = `${-(canvas.height - canvas.height * canvasScaleRatio) / 2}px`;
                if (scrollRatio > imageBlendHeight.end) {
                    canvas_scale.in = canvasScaleRatio;
                    canvas_scale.out = document.body.offsetWidth / (1.5 * canvas.width);
                    canvas_scale.start = imageBlendHeight.end;
                    canvas_scale.end = imageBlendHeight.end + 0.2;
                    canvas.style.transform = `scale(${calcValue_1.calcValues(canvas_scale, currentYOffset, currentScene)})`;
                    canvas.style.marginTop = "0";
                }
                if (scrollRatio > canvas_scale.end && canvas_scale.end > 0) {
                    canvas.classList.remove("sticky");
                    canvas.style.marginTop = `${scrollHeight * 0.4}px`;
                    canvasCaption_opacity.start = canvas_scale.end;
                    canvasCaption_opacity.end = canvas_scale.end + 0.1;
                    canvasCaption_translateY.start = canvas_scale.end;
                    canvasCaption_translateY.end = canvas_scale.end + 0.1;
                    canvasCaption.style.opacity = `${calcValue_1.calcValues(canvasCaption_opacity, currentYOffset, currentScene)}`;
                    canvasCaption.style.transform = `translate3d(0, ${calcValue_1.calcValues(canvasCaption_translateY, currentYOffset, currentScene)}%, 0)`;
                }
            }
            break;
        }
    }
}
exports.playAnimation = playAnimation;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sceneInfo = void 0;
exports.sceneInfo = [
    {
        // 0
        type: "sticky",
        heightNum: 5,
        scrollHeight: 0,
        objs: {
            container: document.querySelector("#scroll-section-0"),
            messageA: document.querySelector("#scroll-section-0 .main-message.a"),
            messageB: document.querySelector("#scroll-section-0 .main-message.b"),
            messageC: document.querySelector("#scroll-section-0 .main-message.c"),
            messageD: document.querySelector("#scroll-section-0 .main-message.d"),
            canvas: document.querySelector("#video-canvas-0"),
            context: document.querySelector("#video-canvas-0").getContext("2d"),
            videoImages: [],
        },
        values: {
            videoImageCount: 181,
            imageSequence: { in: 0, out: 180, start: 0, end: 1 },
            canvas_opacity: { in: 1, out: 0, start: 0.9, end: 1 },
            messageA_opacity_in: { in: 0, out: 1, start: 0.1, end: 0.2 },
            messageA_opacity_out: { in: 1, out: 0, start: 0.25, end: 0.3 },
            messageA_translateY_in: { in: 20, out: 0, start: 0.1, end: 0.2 },
            messageA_translateY_out: { in: 0, out: -20, start: 0.25, end: 0.3 },
            messageB_opacity_in: { in: 0, out: 1, start: 0.3, end: 0.4 },
            messageB_opacity_out: { in: 1, out: 0, start: 0.45, end: 0.5 },
            messageB_translateY_in: { in: 20, out: 0, start: 0.3, end: 0.4 },
            messageB_translateY_out: { in: 0, out: -20, start: 0.45, end: 0.5 },
            messageC_opacity_in: { in: 0, out: 1, start: 0.5, end: 0.6 },
            messageC_opacity_out: { in: 1, out: 0, start: 0.65, end: 0.7 },
            messageC_translateY_in: { in: 20, out: 0, start: 0.5, end: 0.6 },
            messageC_translateY_out: { in: 0, out: -20, start: 0.65, end: 0.7 },
            messageD_opacity_in: { in: 0, out: 1, start: 0.7, end: 0.8 },
            messageD_opacity_out: { in: 1, out: 0, start: 0.85, end: 0.9 },
            messageD_translateY_in: { in: 20, out: 0, start: 0.7, end: 0.8 },
            messageD_translateY_out: { in: 0, out: -20, start: 0.85, end: 0.9 },
        },
    },
    {
        // 1
        type: "normal",
        heightNum: 5,
        scrollHeight: 0,
        objs: {
            container: document.querySelector("#scroll-section-1"),
        },
        values: null,
    },
    {
        // 2
        type: "sticky",
        heightNum: 5,
        scrollHeight: 0,
        objs: {
            container: document.querySelector("#scroll-section-2"),
            messageA: document.querySelector("#scroll-section-2 .a"),
            messageB: document.querySelector("#scroll-section-2 .b"),
            messageC: document.querySelector("#scroll-section-2 .c"),
            pinB: document.querySelector("#scroll-section-2 .b .pin"),
            pinC: document.querySelector("#scroll-section-2 .c .pin"),
            canvas: document.querySelector("#video-canvas-1"),
            context: document.querySelector("#video-canvas-1").getContext("2d"),
            videoImages: [],
        },
        values: {
            videoImageCount: 58,
            imageSequence: { in: 0, out: 57, start: 0, end: 1 },
            canvas_opacity_in: { in: 0, out: 1, start: 0, end: 0.1 },
            canvas_opacity_out: { in: 1, out: 0, start: 0.95, end: 1 },
            messageA_translateY_in: { in: 20, out: 0, start: 0.15, end: 0.2 },
            messageB_translateY_in: { in: 30, out: 0, start: 0.6, end: 0.65 },
            messageC_translateY_in: { in: 30, out: 0, start: 0.87, end: 0.92 },
            messageA_opacity_in: { in: 0, out: 1, start: 0.25, end: 0.3 },
            messageB_opacity_in: { in: 0, out: 1, start: 0.6, end: 0.65 },
            messageC_opacity_in: { in: 0, out: 1, start: 0.87, end: 0.92 },
            messageA_translateY_out: { in: 0, out: -20, start: 0.4, end: 0.45 },
            messageB_translateY_out: { in: 0, out: -20, start: 0.68, end: 0.73 },
            messageC_translateY_out: { in: 0, out: -20, start: 0.95, end: 1 },
            messageA_opacity_out: { in: 1, out: 0, start: 0.4, end: 0.45 },
            messageB_opacity_out: { in: 1, out: 0, start: 0.68, end: 0.73 },
            messageC_opacity_out: { in: 1, out: 0, start: 0.95, end: 1 },
            pinB_opacity_in: { in: 0, out: 1, start: 0.6, end: 0.65 },
            pinB_opacity_out: { in: 1, out: 0, start: 0.68, end: 0.73 },
            pinB_scaleY: { in: 0.5, out: 1, start: 0.6, end: 0.65 },
            pinC_opacity_in: { in: 0, out: 1, start: 0.87, end: 0.92 },
            pinC_opacity_out: { in: 1, out: 0, start: 0.95, end: 1 },
            pinC_scaleY: { in: 0.5, out: 1, start: 0.87, end: 0.92 },
        },
    },
    {
        // 3
        type: "sticky",
        heightNum: 5,
        scrollHeight: 0,
        objs: {
            container: document.querySelector("#scroll-section-3"),
            canvasCaption: document.querySelector(".canvas-caption"),
            canvas: document.querySelector(".image-blend-canvas"),
            context: document.querySelector(".image-blend-canvas").getContext("2d"),
            imagesPath: ["./images/EPAS.JPG", "./images/MullaeInstant.png"],
            images: [],
        },
        values: {
            rect1X: { in: 0, out: 0, start: 0, end: 0 },
            rect2X: { in: 0, out: 0, start: 0, end: 0 },
            imageBlendHeight: { in: 0, out: 0, start: 0, end: 0 },
            canvas_scale: { in: 0, out: 0, start: 0, end: 0 },
            canvasCaption_opacity: { in: 0, out: 1, start: 0, end: 0 },
            canvasCaption_translateY: { in: 20, out: 0, start: 0, end: 0 },
            rectStartY: 0,
        },
    },
];

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setCanvasImages = void 0;
const sceneInfo_1 = require("./sceneInfo");
function setCanvasImages() {
    let imgElem1;
    const objs1 = sceneInfo_1.sceneInfo[0].objs;
    const values1 = sceneInfo_1.sceneInfo[0].values;
    for (let i = 0; i < values1.videoImageCount; i++) {
        imgElem1 = new Image();
        imgElem1.src = `./video/003/IMG_${String(1 + i).padStart(3, "0")}.JPG`;
        objs1.videoImages.push(imgElem1);
    }
    let imgElem2;
    const objs2 = sceneInfo_1.sceneInfo[2].objs;
    const values2 = sceneInfo_1.sceneInfo[2].values;
    for (let i = 0; i < values2.videoImageCount; i++) {
        imgElem2 = new Image();
        imgElem2.src = `./video/004/IMG-${156 + i}.JPG`;
        objs2.videoImages.push(imgElem2);
    }
    let imgElem3;
    const objs3 = sceneInfo_1.sceneInfo[3].objs;
    for (let i = 0; i < objs3.imagesPath.length; i++) {
        imgElem3 = new Image();
        imgElem3.src = objs3.imagesPath[i];
        objs3.images.push(imgElem3);
    }
}
exports.setCanvasImages = setCanvasImages;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setLayout = void 0;
const sceneInfo_1 = require("./sceneInfo");
function setLayout(yOffset, currentScene) {
    // 각 스크롤 섹션의 높이 세팅
    sceneInfo_1.sceneInfo.map((item) => {
        if (item.type === "sticky") {
            item.scrollHeight = item.heightNum * window.innerHeight;
        }
        else {
            item.scrollHeight = item.objs.container.offsetHeight;
        }
        item.objs.container.style.height = `${item.scrollHeight}px`;
    });
    let totalScrollHeight = 0;
    for (let i = 0; i < sceneInfo_1.sceneInfo.length; i++) {
        totalScrollHeight += sceneInfo_1.sceneInfo[i].scrollHeight;
        if (totalScrollHeight >= yOffset) {
            currentScene = i;
            break;
        }
    }
    document.body.setAttribute("id", `show-scene-${currentScene}`);
    const heightRatio = window.innerHeight / 1080;
    sceneInfo_1.sceneInfo[0].objs.canvas.style.transform = `translate3d(-50%, -50%, 0) scale(${heightRatio})`;
    sceneInfo_1.sceneInfo[2].objs.canvas.style.transform = `translate3d(-50%, -50%, 0) scale(${heightRatio})`;
}
exports.setLayout = setLayout;
